package cortexanalystapp

import (
	"bytes"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"strings"

	"gopkg.in/yaml.v3"
)

// OnSignal will run the supplied function when/if the specified signals
// are received.
func OnSignal(fn func(), signals ...os.Signal) {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, signals...)
	go func() {
		sig := <-sigCh
		fmt.Println("received signal:", sig)
		fn()
		signal.Stop(sigCh)
	}()
}

// YAMLFlag represents a command line flag, whose value is a YAML string.
// The YAML is decoded into an object of the specified type.
type YAMLFlag[T any] struct {
	Value   T
	IsEmpty bool
}

// String implements pflag.Value
func (f *YAMLFlag[T]) String() string {
	var buf bytes.Buffer
	enc := yaml.NewEncoder(&buf)
	enc.SetIndent(2)
	if err := enc.Encode(f.Value); err != nil {
		// Should never happen.
		panic(fmt.Sprintf("failed to encode %#v to YAML: %v", f.Value, err))
	}
	enc.Close()
	return buf.String()
}

// Set implements pflag.Value
func (f *YAMLFlag[T]) Set(s string) error {
	if strings.TrimSpace(s) == "" {
		// Special case: the YAML parser will EOF on this input.
		f.IsEmpty = true
		return nil
	}

	dec := yaml.NewDecoder(strings.NewReader(s))
	if err := dec.Decode(&f.Value); err != nil {
		return fmt.Errorf("failed to decode yaml: %w", err)
	}
	return nil
}

// Type implements pflag.Value
func (f *YAMLFlag[T]) Type() string {
	return fmt.Sprintf("YAML representation of %T", f.Value)
}

// ReadAvalancheRSAKey parses the first PKCS1 or PKCS8 encoded RSA private key.
// This is used to read keys generated by Avalanche.
func ReadAvalancheRSAKey(rawKey []byte) (*rsa.PrivateKey, error) {
	keyBlock, _ := pem.Decode(rawKey)
	if keyBlock == nil {
		return nil, errors.New("no PEM data found in raw key")
	}

	switch keyBlock.Type {
	case "RSA PRIVATE KEY":
		return x509.ParsePKCS1PrivateKey(keyBlock.Bytes)
	case "PRIVATE KEY":
		return parsePKCS8RSAKey(keyBlock.Bytes)
	default:
		return nil, fmt.Errorf("unsupported key type: %v", keyBlock.Type)
	}
}

func parsePKCS8RSAKey(bytes []byte) (*rsa.PrivateKey, error) {
	untypedKey, err := x509.ParsePKCS8PrivateKey(bytes)
	if err != nil {
		return nil, err
	}

	key, ok := untypedKey.(*rsa.PrivateKey)
	if !ok {
		return nil, fmt.Errorf("key %T is not of type *rsa.PrivateKey", key)
	}
	return key, nil
}
