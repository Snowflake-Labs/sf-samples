import pako from "pako";

// Ordered list of potential delimiter characters
const DELIMITER_CHARS = ["|", "#", "[", "]"];

// Alphanumeric character set for keyword IDs (62 characters total)
const KEYWORD_ID_CHARS =
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

// Dictionary mapping keywords to their alphanumeric IDs
const KEYWORD_TO_ID = {
  // JSON keys (most frequent first for shorter IDs)
  '"content"': "a",
  '"role":': "b",
  '"type":': "c",
  '"text":': "d",
  '"metaType":': "e",
  '"index":': "f",
  '"statement":': "g",
  '"data":': "h",
  '"metadata":': "i",
  '"fullContent":': "j",
  '"columns":': "k",
  '"name":': "l",
  '"length":': "m",
  '"precision":': "n",
  '"scale":': "o",
  '"nullable":': "p",
  '"totalRows":': "q",

  // Common values
  '"analyst"': "r",
  '"user"': "s",
  '"sql"': "t",
  '"sql_results"': "u",

  // SQL keywords
  SELECT: "v",
  FROM: "w",
  WHERE: "x",
  AND: "y",
  CASE: "z",
  WHEN: "A",
  THEN: "B",
  END: "C",
  WITH: "D",
  "GROUP BY": "E",
  "ORDER BY": "F",
  "LEFT OUTER JOIN": "G",
  "INNER JOIN": "H",
  "RIGHT JOIN": "I",

  // Common phrases and patterns
  "Generated by Cortex Analyst": "M",
  "This is our intepretation of your question": "N",
};

// Create reverse mapping for decompression
const ID_TO_KEYWORD = Object.fromEntries(
  Object.entries(KEYWORD_TO_ID).map(([keyword, id]) => [id, keyword])
);

/**
 * Find the best delimiter character that's not present in the text
 * @param {string} text - Text to analyze
 * @returns {string|null} Best delimiter character or null if all are present
 */
function findBestDelimiter(text) {
  for (const delimiter of DELIMITER_CHARS) {
    if (!text.includes(delimiter)) {
      return delimiter;
    }
  }
  return null; // All delimiters are present in the text
}

/**
 * Apply dictionary compression using safe delimiter encoding
 * @param {string} text - Text to compress
 * @returns {string} Dictionary-compressed text with delimiter prefix
 */
function applyDictionary(text) {
  const delimiter = findBestDelimiter(text);

  // If no safe delimiter found, return original with $ prefix (no encoding)
  if (!delimiter) {
    return "$" + text;
  }

  let compressed = text;

  // Sort keywords by length (longer first) to avoid partial replacements
  const sortedKeywords = Object.keys(KEYWORD_TO_ID).sort(
    (a, b) => b.length - a.length
  );

  // Replace each keyword with delimited ID
  for (const keyword of sortedKeywords) {
    const id = KEYWORD_TO_ID[keyword];
    const encoded = `${delimiter}${id}${delimiter}`;
    compressed = compressed.replaceAll(keyword, encoded);
  }

  // Prepend with the delimiter used
  return delimiter + compressed;
}

/**
 * Reverse dictionary compression
 * @param {string} text - Dictionary-compressed text with delimiter prefix
 * @returns {string} Original text
 */
function reverseDictionary(text) {
  if (text.length === 0) return text;

  const firstChar = text[0];
  const content = text.slice(1);

  // If first character is $, no encoding was applied
  if (firstChar === "$") {
    return content;
  }

  // Use the first character as delimiter
  const delimiter = firstChar;
  let restored = content;

  // Create regex pattern to find all encoded keywords
  const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const pattern = new RegExp(
    `${escapedDelimiter}([${KEYWORD_ID_CHARS}])${escapedDelimiter}`,
    "g"
  );

  // Replace all encoded patterns with original keywords
  restored = restored.replace(pattern, (match, id) => {
    return ID_TO_KEYWORD[id] || match; // Fallback to original if ID not found
  });

  return restored;
}

/**
 * Compress messages array to a URL-safe base64 string using optimal configuration
 * @param {Array} messages - Array of message objects
 * @returns {string} Compressed and base64 encoded string
 */
export function compressMessages(messages) {
  try {
    // Convert to JSON string
    const jsonString = JSON.stringify(messages);

    // Apply dictionary compression first
    const dictCompressed = applyDictionary(jsonString);

    // Use DeflateRaw for best compression (no headers)
    const compressed = pako.deflateRaw(dictCompressed, { level: 6 });

    // Convert to base64 and make URL-safe
    const base64 = btoa(String.fromCharCode(...compressed));
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  } catch (error) {
    console.error("Error compressing messages:", error);
    throw error;
  }
}

/**
 * Decompress a base64 string back to messages array
 * @param {string} compressed - Compressed base64 string
 * @returns {Array} Array of message objects
 */
export function decompressMessages(compressed) {
  try {
    // Restore base64 padding and characters
    let base64 = compressed.replace(/-/g, "+").replace(/_/g, "/");
    while (base64.length % 4) {
      base64 += "=";
    }

    // Decode from base64
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }

    // Decompress using DeflateRaw
    const decompressed = pako.inflateRaw(bytes, { to: "string" });

    // Reverse dictionary compression
    const restored = reverseDictionary(decompressed);

    // Parse JSON
    return JSON.parse(restored);
  } catch (error) {
    console.error("Error decompressing messages:", error);
    throw error;
  }
}

/**
 * Get compression statistics with optimized method
 * @param {Array} messages - Array of message objects
 * @returns {Object} Compression stats
 */
export function getCompressionStats(messages) {
  const original = JSON.stringify(messages);
  const dictCompressed = applyDictionary(original);
  const compressed = compressMessages(messages);

  // Determine which delimiter was used
  const delimiter = dictCompressed[0];
  const encodingUsed = delimiter !== "$";

  return {
    originalSize: original.length,
    dictionarySize: dictCompressed.length,
    compressedSize: compressed.length,
    compressionRatio:
      ((compressed.length / original.length) * 100).toFixed(1) + "%",
    spaceSaved: original.length - compressed.length,
    dictionarySavings: original.length - dictCompressed.length,
    compressionSavings: dictCompressed.length - compressed.length,
    encodingUsed,
    delimiterUsed: encodingUsed ? delimiter : "none",
  };
}
