USE ROLE <% ctx.env.finops_db_admin_role%>;
USE DATABASE <% ctx.env.finops_acct_db %>;
USE SCHEMA <% ctx.env.finops_acct_schema %>;

CREATE OR REPLACE VIEW ORGV1_CONTRACT_ACTUAL_AND_FORECAST_LINEAR COMMENT = 'Title: Organizational Contract Actual and Forecast Linear. Description: Analyze the contract actual amount and linear forecast in currency of the organization.'
AS
WITH ci
AS (
    -- Retrieve current organizational contract amounts
    -- Note: if contract_items is not available, create a select of static values as an alternative.
    -- Also: Validate these numbers below as could be missing or incorrect values.
    SELECT 
        -- CONTRACT_ITEM, 
        START_DATE,
        CASE WHEN CONTRACT_ITEM IN ('Capacity', 'Additional Capacity') THEN END_DATE ELSE START_DATE END AS END_DATE, -- INSTEAD OF SPREADING OUT SHORT TERM ITEMS, MAKE THEM 1 DAY ADDITIONS.
        DATEDIFF('DAY', START_DATE, CASE WHEN CONTRACT_ITEM IN ('Capacity', 'Additional Capacity') THEN END_DATE ELSE START_DATE END)+1 AS CONTRACT_LENGTH_DAYS,
        AMOUNT,
        SUM(AMOUNT) OVER (
            ORDER BY NULL
            ) AS CONTRACT_TOTAL,
        SUM(AMOUNT) OVER (
            ORDER BY START_DATE
            ) AS CONTRACT_RUNNING_SUM,
        ROUND(AMOUNT / CONTRACT_LENGTH_DAYS, 2) AS DAILY_AMOUNT
    FROM SNOWFLAKE.ORGANIZATION_USAGE.CONTRACT_ITEMS
    WHERE START_DATE <= CURRENT_DATE()
        -- AND CONTRACT_ITEM IN ('Capacity', 'Additional Capacity', 'Free Usage')
        AND EXPIRATION_DATE IS NULL
)
, SEQ AS (
   -- Generate a sequence of numbers using contract length
   SELECT SEQ4() AS NUM, DATEADD('DAY', NUM, (SELECT MIN(START_DATE) FROM CI )) AS DAY
   FROM TABLE (GENERATOR(ROWCOUNT => (3660))) V
   WHERE NUM <= (
           SELECT DATEDIFF('DAY', MIN(START_DATE), MAX(END_DATE))
           FROM CI
           )
   )
, CAR AS (
    -- Join contract amounts with sequence
    SELECT SEQ.NUM, 
        DAY,   
        CASE
            WHEN DAY BETWEEN START_DATE AND END_DATE
                THEN CONTRACT_LENGTH_DAYS
            ELSE 0
            END AS CONTRACT_LENGTH_DAYS_FILTERED,
        CASE
            WHEN DAY BETWEEN START_DATE AND END_DATE
                THEN DAILY_AMOUNT
            ELSE 0
            END AS DAILY_AMOUNT_FILTERED,
        CASE
            WHEN DAY BETWEEN START_DATE AND END_DATE
                THEN CONTRACT_RUNNING_SUM
            ELSE 0
            END AS CONTRACT_RUNNING_SUM_FILTERED,
    FROM CI
    JOIN SEQ 
    WHERE DAILY_AMOUNT_FILTERED > 0
   )
, CI_DAILY_FULL AS (
    -- What is our daily budget
    SELECT 
        DAY AS CALENDAR_DATE,
        SUM(DAILY_AMOUNT_FILTERED) DAILY_BUDGET_AMOUNT,
        MAX(CONTRACT_RUNNING_SUM_FILTERED) AS CONTRACT_TOTAL_CUMULATIVE,
        DENSE_RANK() OVER (
            ORDER BY DAY
            ) AS DAY_NUM
    FROM CAR
    GROUP BY DAY 
   )
, CI_AGG AS (
    -- Accumulate daily budget amounts
    SELECT CALENDAR_DATE,
        DAILY_BUDGET_AMOUNT,
        SUM(DAILY_BUDGET_AMOUNT) OVER (
            ORDER BY CALENDAR_DATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
            ) AS ACCUMULATED_BUDGET,
        DAY_NUM,
        CONTRACT_TOTAL_CUMULATIVE
    FROM CI_DAILY_FULL
    ) 
, SPEND AS (
    -- Add accumulated spend
    SELECT USAGE_DATE,
        ROUND(SUM(USAGE_IN_CURRENCY), 1) DAILY_TOTAL_COST,
        SUM(DAILY_TOTAL_COST) OVER (
            ORDER BY USAGE_DATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS ACCUMULATED_SPEND
    FROM SNOWFLAKE.ORGANIZATION_USAGE.USAGE_IN_CURRENCY_DAILY D
    JOIN (
        SELECT MIN(START_DATE) AS START_DATE,
            MAX(END_DATE) AS END_DATE
        FROM CI
        ) CI --CARTESIAN JOIN.
    WHERE USAGE_DATE BETWEEN CI.START_DATE AND CI.END_DATE
    GROUP BY 1
    ) 
, COMBINE AS (
    -- Join contract items with spend
   SELECT 
       N.DAY_NUM,
       C.USAGE_DATE,
       N.CALENDAR_DATE,
       C.DAILY_TOTAL_COST,
       C.ACCUMULATED_SPEND,
       N.DAILY_BUDGET_AMOUNT,
       N.ACCUMULATED_BUDGET,
       N.CONTRACT_TOTAL_CUMULATIVE
   FROM CI_AGG N
   LEFT JOIN SPEND C ON N.CALENDAR_DATE = C.USAGE_DATE
   )
, RUN AS (
    -- Calculate weekly run rate
    SELECT AVG(DAILY_TOTAL_COST) AS RUN_RATE_7_DAY
    FROM COMBINE
    WHERE USAGE_DATE BETWEEN DATEADD(DAY, -8, CURRENT_DATE())
         AND DATEADD(DAY, -1, CURRENT_DATE())
    )
, RUN_30 AS (
    -- Calculate monthly run rate
    SELECT AVG(DAILY_TOTAL_COST) AS RUN_RATE_30_DAY
    FROM COMBINE
    WHERE USAGE_DATE BETWEEN DATEADD(DAY, -31, CURRENT_DATE())
            AND DATEADD(DAY, -1, CURRENT_DATE())
    )
SELECT 
    CALENDAR_DATE,
    USAGE_DATE,
    CONTRACT_TOTAL_CUMULATIVE,
    C.DAY_NUM,
    DAILY_BUDGET_AMOUNT,
    ACCUMULATED_BUDGET,
    DAILY_TOTAL_COST,
    MAX(IFF(CALENDAR_DATE > CURRENT_DATE(), NULL, C.DAY_NUM)) OVER ( ORDER BY USAGE_DATE ) AS DAYS_SINCE_START_ACTUAL,
    MAX(ACCUMULATED_SPEND) OVER ( ORDER BY CALENDAR_DATE ) AS ACTUAL_SPEND,
    (ACCUMULATED_BUDGET - ACTUAL_SPEND) AS BUDGET_REMAINING,
    CASE WHEN C.CALENDAR_DATE > CURRENT_DATE() THEN ROUND(((C.DAY_NUM - DAYS_SINCE_START_ACTUAL) * RUN.RUN_RATE_7_DAY) + ACTUAL_SPEND) ELSE NULL END AS RUN_RATE_7_FORECAST_ACCUMULATED_AMOUNT,
    CASE WHEN C.CALENDAR_DATE > CURRENT_DATE() THEN ROUND(((C.DAY_NUM - DAYS_SINCE_START_ACTUAL) * RUN_30.RUN_RATE_30_DAY) + ACTUAL_SPEND) ELSE NULL END AS RUN_RATE_30_FORECAST_ACCUMULATED_AMOUNT,
    CASE
        WHEN DAILY_TOTAL_COST IS NULL
            THEN ROUND(DIV0(CONTRACT_TOTAL_CUMULATIVE - ACTUAL_SPEND, (
                            (
                                SELECT DATEDIFF('DAY', MIN(START_DATE), MAX(END_DATE))
                                FROM CI
                                ) - DAYS_SINCE_START_ACTUAL
                            )), 1)
        ELSE NULL
        END AS SLOPE,
    ROUND(SLOPE * (DAY_NUM - DAYS_SINCE_START_ACTUAL) + ACTUAL_SPEND, 1) AS IDEAL_SLOPE, --WHAT IS THE RATE OF SPEND TO GET TO PERFECT CONTRACT $0 POINT.
    RUN_RATE_7_DAY,
    RUN_RATE_30_DAY
FROM COMBINE C
CROSS JOIN RUN
CROSS JOIN RUN_30
ORDER BY 1
;